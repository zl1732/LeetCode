{"id":1477,"fid":"1352","name":"最后 K 个数的乘积","slug":"product-of-the-last-k-numbers","link":"https://leetcode.cn/problems/product-of-the-last-k-numbers/description/","percent":51.154785371737916,"level":"Medium","category":"algorithms","en_name":"Product of the Last K Numbers","cn_name":"最后 K 个数的乘积","totalAC":"17.4K","totalSubmit":"34K","likes":124,"dislikes":0,"desc":"<p>设计一个算法，该算法接受一个整数流并检索该流中最后 <code>k</code> 个整数的乘积。</p>\n\n<p>实现&nbsp;<code>ProductOfNumbers</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>ProductOfNumbers()</code>&nbsp;用一个空的流初始化对象。</li>\n\t<li><code>void add(int num)</code>&nbsp;将数字&nbsp;<code>num</code>&nbsp;添加到当前数字列表的最后面。</li>\n\t<li><code>int getProduct(int k)</code>&nbsp;返回当前数字列表中，最后&nbsp;<code>k</code>&nbsp;个数字的乘积。你可以假设当前列表中始终 <strong>至少</strong> 包含 <code>k</code> 个数字。</li>\n</ul>\n\n<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32 位整数范围内，不会溢出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ProductOfNumbers\",\"add\",\"add\",\"add\",\"add\",\"add\",\"getProduct\",\"getProduct\",\"getProduct\",\"add\",\"getProduct\"]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n\n<strong>输出：</strong>\n[null,null,null,null,null,null,20,40,0,null,32]\n\n<strong>解释：</strong>\nProductOfNumbers productOfNumbers = new ProductOfNumbers();\nproductOfNumbers.add(3);        // [3]\nproductOfNumbers.add(0);        // [3,0]\nproductOfNumbers.add(2);        // [3,0,2]\nproductOfNumbers.add(5);        // [3,0,2,5]\nproductOfNumbers.add(4);        // [3,0,2,5,4]\nproductOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20\nproductOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40\nproductOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0\nproductOfNumbers.add(8);        // [3,0,2,5,4,8]\nproductOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num&nbsp;&lt;=&nbsp;100</code></li>\n\t<li><code>1 &lt;= k &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>add</code> 和 <code>getProduct</code>&nbsp;最多被调用&nbsp;<code>4 * 10<sup>4</sup></code> 次。</li>\n\t<li>在任何时间点流的乘积都在 32 位整数范围内。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>您能否 <strong>同时</strong> 将 <code>GetProduct</code> 和 <code>Add</code> 的实现改为 <code>O(1)</code> 时间复杂度，而不是 <code>O(k)</code> 时间复杂度？</p>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class ProductOfNumbers {\npublic:\n    ProductOfNumbers() {\n        \n    }\n    \n    void add(int num) {\n        \n    }\n    \n    int getProduct(int k) {\n        \n    }\n};\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers* obj = new ProductOfNumbers();\n * obj->add(num);\n * int param_2 = obj->getProduct(k);\n */"},{"value":"java","text":"Java","defaultCode":"class ProductOfNumbers {\n\n    public ProductOfNumbers() {\n        \n    }\n    \n    public void add(int num) {\n        \n    }\n    \n    public int getProduct(int k) {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = new ProductOfNumbers();\n * obj.add(num);\n * int param_2 = obj.getProduct(k);\n */"},{"value":"python3","text":"Python3","defaultCode":"class ProductOfNumbers:\n\n    def __init__(self):\n        \n\n    def add(self, num: int) -> None:\n        \n\n    def getProduct(self, k: int) -> int:\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)"},{"value":"python","text":"Python","defaultCode":"class ProductOfNumbers(object):\n\n    def __init__(self):\n        \n\n    def add(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        \n\n    def getProduct(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)"},{"value":"javascript","text":"JavaScript","defaultCode":"\nvar ProductOfNumbers = function() {\n    \n};\n\n/** \n * @param {number} num\n * @return {void}\n */\nProductOfNumbers.prototype.add = function(num) {\n    \n};\n\n/** \n * @param {number} k\n * @return {number}\n */\nProductOfNumbers.prototype.getProduct = function(k) {\n    \n};\n\n/** \n * Your ProductOfNumbers object will be instantiated and called as such:\n * var obj = new ProductOfNumbers()\n * obj.add(num)\n * var param_2 = obj.getProduct(k)\n */"},{"value":"typescript","text":"TypeScript","defaultCode":"class ProductOfNumbers {\n    constructor() {\n        \n    }\n\n    add(num: number): void {\n        \n    }\n\n    getProduct(k: number): number {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * var obj = new ProductOfNumbers()\n * obj.add(num)\n * var param_2 = obj.getProduct(k)\n */"},{"value":"csharp","text":"C#","defaultCode":"public class ProductOfNumbers {\n\n    public ProductOfNumbers() {\n        \n    }\n    \n    public void Add(int num) {\n        \n    }\n    \n    public int GetProduct(int k) {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = new ProductOfNumbers();\n * obj.Add(num);\n * int param_2 = obj.GetProduct(k);\n */"},{"value":"c","text":"C","defaultCode":"\n\n\ntypedef struct {\n    \n} ProductOfNumbers;\n\n\nProductOfNumbers* productOfNumbersCreate() {\n    \n}\n\nvoid productOfNumbersAdd(ProductOfNumbers* obj, int num) {\n    \n}\n\nint productOfNumbersGetProduct(ProductOfNumbers* obj, int k) {\n    \n}\n\nvoid productOfNumbersFree(ProductOfNumbers* obj) {\n    \n}\n\n/**\n * Your ProductOfNumbers struct will be instantiated and called as such:\n * ProductOfNumbers* obj = productOfNumbersCreate();\n * productOfNumbersAdd(obj, num);\n \n * int param_2 = productOfNumbersGetProduct(obj, k);\n \n * productOfNumbersFree(obj);\n*/"},{"value":"golang","text":"Go","defaultCode":"type ProductOfNumbers struct {\n    \n}\n\n\nfunc Constructor() ProductOfNumbers {\n    \n}\n\n\nfunc (this *ProductOfNumbers) Add(num int)  {\n    \n}\n\n\nfunc (this *ProductOfNumbers) GetProduct(k int) int {\n    \n}\n\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(num);\n * param_2 := obj.GetProduct(k);\n */"},{"value":"kotlin","text":"Kotlin","defaultCode":"class ProductOfNumbers() {\n\n    fun add(num: Int) {\n        \n    }\n\n    fun getProduct(k: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * var obj = ProductOfNumbers()\n * obj.add(num)\n * var param_2 = obj.getProduct(k)\n */"},{"value":"swift","text":"Swift","defaultCode":"\nclass ProductOfNumbers {\n\n    init() {\n        \n    }\n    \n    func add(_ num: Int) {\n        \n    }\n    \n    func getProduct(_ k: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * let obj = ProductOfNumbers()\n * obj.add(num)\n * let ret_2: Int = obj.getProduct(k)\n */"},{"value":"rust","text":"Rust","defaultCode":"struct ProductOfNumbers {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl ProductOfNumbers {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, num: i32) {\n        \n    }\n    \n    fn get_product(&self, k: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * let obj = ProductOfNumbers::new();\n * obj.add(num);\n * let ret_2: i32 = obj.get_product(k);\n */"},{"value":"ruby","text":"Ruby","defaultCode":"class ProductOfNumbers\n    def initialize()\n        \n    end\n\n\n=begin\n    :type num: Integer\n    :rtype: Void\n=end\n    def add(num)\n        \n    end\n\n\n=begin\n    :type k: Integer\n    :rtype: Integer\n=end\n    def get_product(k)\n        \n    end\n\n\nend\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers.new()\n# obj.add(num)\n# param_2 = obj.get_product(k)"},{"value":"php","text":"PHP","defaultCode":"class ProductOfNumbers {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $num\n     * @return NULL\n     */\n    function add($num) {\n        \n    }\n  \n    /**\n     * @param Integer $k\n     * @return Integer\n     */\n    function getProduct($k) {\n        \n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * $obj = ProductOfNumbers();\n * $obj->add($num);\n * $ret_2 = $obj->getProduct($k);\n */"},{"value":"dart","text":"Dart","defaultCode":"class ProductOfNumbers {\n\n  ProductOfNumbers() {\n    \n  }\n  \n  void add(int num) {\n    \n  }\n  \n  int getProduct(int k) {\n    \n  }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = ProductOfNumbers();\n * obj.add(num);\n * int param2 = obj.getProduct(k);\n */"},{"value":"scala","text":"Scala","defaultCode":"class ProductOfNumbers() {\n\n    def add(num: Int): Unit = {\n        \n    }\n\n    def getProduct(k: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * val obj = new ProductOfNumbers()\n * obj.add(num)\n * val param_2 = obj.getProduct(k)\n */"},{"value":"elixir","text":"Elixir","defaultCode":"defmodule ProductOfNumbers do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(num :: integer) :: any\n  def add(num) do\n    \n  end\n\n  @spec get_product(k :: integer) :: integer\n  def get_product(k) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ProductOfNumbers.init_()\n# ProductOfNumbers.add(num)\n# param_2 = ProductOfNumbers.get_product(k)\n\n# ProductOfNumbers.init_ will be called before every test case, in which you can do some necessary initializations."},{"value":"erlang","text":"Erlang","defaultCode":"-spec product_of_numbers_init_() -> any().\nproduct_of_numbers_init_() ->\n  .\n\n-spec product_of_numbers_add(Num :: integer()) -> any().\nproduct_of_numbers_add(Num) ->\n  .\n\n-spec product_of_numbers_get_product(K :: integer()) -> integer().\nproduct_of_numbers_get_product(K) ->\n  .\n\n\n%% Your functions will be called as such:\n%% product_of_numbers_init_(),\n%% product_of_numbers_add(Num),\n%% Param_2 = product_of_numbers_get_product(K),\n\n%% product_of_numbers_init_ will be called before every test case, in which you can do some necessary initializations."},{"value":"racket","text":"Racket","defaultCode":"(define product-of-numbers%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add num)\n      )\n    ; get-product : exact-integer? -> exact-integer?\n    (define/public (get-product k)\n      )))\n\n;; Your product-of-numbers% object will be instantiated and called as such:\n;; (define obj (new product-of-numbers%))\n;; (send obj add num)\n;; (define param_2 (send obj get-product k))"},{"value":"cangjie","text":"Cangjie","defaultCode":"class ProductOfNumbers {\n    init() {\n\n    }\n    \n    func add(num: Int64): Unit {\n\n    }\n    \n    func getProduct(k: Int64): Int64 {\n\n    }\n}\n\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * let obj: ProductOfNumbers = ProductOfNumbers()\n * obj.add(num)\n * let param_2 = obj.getProduct(k)\n */"}],"testcase":"[\"ProductOfNumbers\",\"add\",\"add\",\"add\",\"add\",\"add\",\"getProduct\",\"getProduct\",\"getProduct\",\"add\",\"getProduct\"]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]","testable":true,"templateMeta":{"classname":"ProductOfNumbers","constructor":{"params":[]},"methods":[{"params":[{"type":"integer","name":"num"}],"name":"add","return":{"type":"void"}},{"params":[{"type":"integer","name":"k"}],"name":"getProduct","return":{"type":"integer"}}],"return":{"type":"boolean"},"systemdesign":true}}
{"id":912,"fid":"528","name":"按权重随机选择","slug":"random-pick-with-weight","link":"https://leetcode.cn/problems/random-pick-with-weight/description/","percent":49.597281561680255,"level":"Medium","category":"algorithms","en_name":"Random Pick with Weight","cn_name":"按权重随机选择","totalAC":"69.8K","totalSubmit":"140.7K","likes":357,"dislikes":0,"desc":"<p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p>\n\n<p>请你实现一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code>&nbsp;的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p>\n\n<ol>\n</ol>\n\n<ul>\n\t<li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3)&nbsp;= 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3)&nbsp;= 0.75</code>（即，<code>75%</code>）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n<strong>输出：</strong>\n[null,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,1,1,1,1,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pickIndex</code>&nbsp;将被调用不超过 <code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    Solution(vector<int>& w) {\n        \n    }\n    \n    int pickIndex() {\n        \n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(w);\n * int param_1 = obj->pickIndex();\n */"},{"value":"java","text":"Java","defaultCode":"class Solution {\n\n    public Solution(int[] w) {\n        \n    }\n    \n    public int pickIndex() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(w);\n * int param_1 = obj.pickIndex();\n */"},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n\n    def __init__(self, w: List[int]):\n        \n\n    def pickIndex(self) -> int:\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(w)\n# param_1 = obj.pickIndex()"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n\n    def __init__(self, w):\n        \"\"\"\n        :type w: List[int]\n        \"\"\"\n        \n\n    def pickIndex(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(w)\n# param_1 = obj.pickIndex()"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {number[]} w\n */\nvar Solution = function(w) {\n    \n};\n\n/**\n * @return {number}\n */\nSolution.prototype.pickIndex = function() {\n    \n};\n\n/** \n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */"},{"value":"typescript","text":"TypeScript","defaultCode":"class Solution {\n    constructor(w: number[]) {\n        \n    }\n\n    pickIndex(): number {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n\n    public Solution(int[] w) {\n        \n    }\n    \n    public int PickIndex() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(w);\n * int param_1 = obj.PickIndex();\n */"},{"value":"c","text":"C","defaultCode":"\n\n\ntypedef struct {\n    \n} Solution;\n\n\nSolution* solutionCreate(int* w, int wSize) {\n    \n}\n\nint solutionPickIndex(Solution* obj) {\n    \n}\n\nvoid solutionFree(Solution* obj) {\n    \n}\n\n/**\n * Your Solution struct will be instantiated and called as such:\n * Solution* obj = solutionCreate(w, wSize);\n * int param_1 = solutionPickIndex(obj);\n \n * solutionFree(obj);\n*/"},{"value":"golang","text":"Go","defaultCode":"type Solution struct {\n    \n}\n\n\nfunc Constructor(w []int) Solution {\n    \n}\n\n\nfunc (this *Solution) PickIndex() int {\n    \n}\n\n\n/**\n * Your Solution object will be instantiated and called as such:\n * obj := Constructor(w);\n * param_1 := obj.PickIndex();\n */"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution(w: IntArray) {\n\n    fun pickIndex(): Int {\n        \n    }\n\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = Solution(w)\n * var param_1 = obj.pickIndex()\n */"},{"value":"swift","text":"Swift","defaultCode":"\nclass Solution {\n\n    init(_ w: [Int]) {\n        \n    }\n    \n    func pickIndex() -> Int {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * let obj = Solution(w)\n * let ret_1: Int = obj.pickIndex()\n */"},{"value":"rust","text":"Rust","defaultCode":"struct Solution {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Solution {\n\n    fn new(w: Vec<i32>) -> Self {\n        \n    }\n    \n    fn pick_index(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * let obj = Solution::new(w);\n * let ret_1: i32 = obj.pick_index();\n */"},{"value":"ruby","text":"Ruby","defaultCode":"class Solution\n\n=begin\n    :type w: Integer[]\n=end\n    def initialize(w)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pick_index()\n        \n    end\n\n\nend\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution.new(w)\n# param_1 = obj.pick_index()"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n    /**\n     * @param Integer[] $w\n     */\n    function __construct($w) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pickIndex() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * $obj = Solution($w);\n * $ret_1 = $obj->pickIndex();\n */"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n\n  Solution(List<int> w) {\n    \n  }\n  \n  int pickIndex() {\n    \n  }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = Solution(w);\n * int param1 = obj.pickIndex();\n */"},{"value":"scala","text":"Scala","defaultCode":"class Solution(_w: Array[Int]) {\n\n    def pickIndex(): Int = {\n        \n    }\n\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * val obj = new Solution(w)\n * val param_1 = obj.pickIndex()\n */"},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec init_(w :: [integer]) :: any\n  def init_(w) do\n    \n  end\n\n  @spec pick_index() :: integer\n  def pick_index() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Solution.init_(w)\n# param_1 = Solution.pick_index()\n\n# Solution.init_ will be called before every test case, in which you can do some necessary initializations."},{"value":"erlang","text":"Erlang","defaultCode":"-spec solution_init_(W :: [integer()]) -> any().\nsolution_init_(W) ->\n  .\n\n-spec solution_pick_index() -> integer().\nsolution_pick_index() ->\n  .\n\n\n%% Your functions will be called as such:\n%% solution_init_(W),\n%% Param_1 = solution_pick_index(),\n\n%% solution_init_ will be called before every test case, in which you can do some necessary initializations."},{"value":"racket","text":"Racket","defaultCode":"(define solution%\n  (class object%\n    (super-new)\n    \n    ; w : (listof exact-integer?)\n    (init-field\n      w)\n    \n    ; pick-index : -> exact-integer?\n    (define/public (pick-index)\n      )))\n\n;; Your solution% object will be instantiated and called as such:\n;; (define obj (new solution% [w w]))\n;; (define param_1 (send obj pick-index))"},{"value":"cangjie","text":"Cangjie","defaultCode":"class Solution {\n    init(w: Array<Int64>) {\n\n    }\n    \n    func pickIndex(): Int64 {\n\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * let obj: Solution = Solution(w)\n * let param_1 = obj.pickIndex()\n */"}],"testcase":"[\"Solution\",\"pickIndex\"]\n[[[1]],[]]","testable":true,"templateMeta":{"classname":"Solution","maxbytesperline":200000,"constructor":{"params":[{"name":"w","type":"integer[]"},{"name":"wSize","type":"integer","lang":"c","value":"size_1"}]},"methods":[{"name":"pickIndex","params":[],"return":{"type":"integer"}}],"systemdesign":true,"params":[{"name":"inputs","type":"integer[]"},{"name":"inputs","type":"integer[]"}],"return":{"type":"list<String>","dealloc":true}}}